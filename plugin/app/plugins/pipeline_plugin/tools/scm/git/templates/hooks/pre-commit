#!/bin/bash 
# Return the function to file validate
function get_validator(){
  local type_file
  [[ $file_name =~ ^Makefile ]] && type_file='makefile' || type_file=$(file $file_name|cut -d':' -f2)
  case $type_file in
    " Bourne-Again shell script, ASCII text executable") echo "bash";;
    " Bourne-Again shell script text executable, ASCII text") echo "bash";;
    " Bourne-Again shell script text executable") echo "bash";;
    " POSIX shell script text executable") echo "sh";;
    *) # By default, it uses the extension file to identify file type 
      base_file_name=$(basename $file_name)
      #get last suffix
      echo ${base_file_name##*.};;
  esac
}


function check_non_printable_chars(){
  local file_name
  local encoding_validator
  local type_file
  file_name=$1
  encoding_validator=""
  [[ $file_name =~ ^Makefile ]] && type_file='text/x-makefile' || type_file=$(file --mime $file_name|awk '{print $2}')
  case $type_file in
    "text/x-makefile");;
    *) if [[ $type_file == text/* ]]; then
          encoding_validator="non_ascii"
       fi 
  esac
  if [[ "$encoding_validator" != "" ]]; then
     source "${validator_dir}/${encoding_validator}.sh"
     is_ascii
  fi
}
validator_dir=$(dirname $0)/validators
n_errors=0
while read file_name; do
  check_non_printable_chars $file_name
  result_code=$?
  if [[ "${result_code}" == 0 ]]; then
    validator_file=$validator_dir/$(get_validator).sh
    if [[ -f $validator_file ]]; then
      source $validator_file
      validation_error=$(validate)
      result_code=$?
    else
      result_code=126
    fi
  fi
  case $result_code in
    126) echo "[WARNING] There is not any validator for $file_name";;
    0) echo "[OK] $file_name";;
    *) echo "[KO] $file_name"
       echo "==================================================================="
       echo -en "${validation_error}\n" 
       n_errors=$((n_errors+1))
       echo "==================================================================="
       ;;
  esac
done < <(git status --porcelain|egrep '^AM |^ M |^M |^A '|awk '{print $2}')
[[ "${n_errors}" == "0" ]] && exit 0
echo "
Errors: ${n_errors}"
exit 1
