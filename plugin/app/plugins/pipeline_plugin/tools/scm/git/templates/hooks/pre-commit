#!/bin/bash

# Return the function to file validate
function get_validator() {
  local type_file
  case $(basename "$FILE_NAME") in
  "sonar-project.properties")
    echo "sonar-project"
    return 0
    ;;
  "thirdparty-rpms.txt")
    echo "thirdparty-rpms"
    return 0
    ;;
  esac
  case $FILE_NAME in
  Makefile | Pipfile | Gemfile | package.json) type_file="$FILE_NAME" ;;
  *) type_file=$(file "$FILE_NAME" | grep -Po '(?<=: ).*') ;;
  esac
  case $type_file in
  "Bourne-Again shell script, ASCII text executable") echo "bash" ;;
  "Bourne-Again shell script text executable, ASCII text") echo "bash" ;;
  "Bourne-Again shell script text executable") echo "bash" ;;
  "Bourne-Again shell script, ASCII text executable, with very long lines") echo "bash" ;;
  "POSIX shell script text executable") echo "sh" ;;
  Makefile | Pipfile | Gemfile | package.json) echo "${type_file}" ;;
  *) # By default, it uses the extension file to identify file type
    base_file_name=$(basename "$FILE_NAME")
    #get last suffix
    echo "${base_file_name##*.}"
    ;;
  esac
}

function check_non_printable_chars() {
  local filename
  local encoding_validator
  local type_file
  filename=$1
  encoding_validator=""
  [[ $filename =~ ^Makefile|\.mk$ ]] && type_file='text/x-makefile' || type_file=$(file --mime "$filename" | awk '{print $2}')
  case $type_file in
  "text/x-makefile") ;;
  *) if [[ $type_file == text/* ]]; then
    encoding_validator="non_ascii"
  fi ;;
  esac
  if [[ $encoding_validator != "" ]]; then
    # shellcheck source=./plugin/app/plugins/pipeline_plugin/tools/scm/git/templates/hooks/validators/Gemfile.sh
    source "${VALIDATOR_DIR}/${encoding_validator}.sh"
    is_ascii
  fi
}

function is_hook_enabled() {
  if [[ $DISABLE_HOOK == "ALL" ]] ||
    [[ $DISABLE_HOOK == "all" ]] ||
    [[ $DISABLE_HOOK == "$1" ]]; then
    return 125
  fi
}

VALIDATOR_DIR=$(dirname "$0")/validators
n_errors=0
errors_files=''
while read -r "${FILE_NAME?}"; do
  if is_hook_enabled "${FILE_NAME}"; then
    check_non_printable_chars "$FILE_NAME"
    result_code=$?
  else
    result_code=0
  fi
  if [[ ${result_code} == 0 ]]; then
    validator=$(get_validator)
    validator_file="$VALIDATOR_DIR/${validator}.sh"
    if [[ -f $validator_file ]]; then
      # shellcheck source=./plugin/app/plugins/pipeline_plugin/tools/scm/git/templates/hooks/validators/Gemfile.sh
      source "$validator_file"
      if is_hook_enabled "${FILE_NAME}"; then
        validation_error=$(validate)
        result_code=$?
      else
        result_code=$?
      fi
    else
      result_code=126
    fi
  fi
  case $result_code in
  125) dp_log.sh "[WARNING] [${validator}] hook disabled for $FILE_NAME" ;;
  126) dp_log.sh "[WARNING] There is not any validator for $FILE_NAME" ;;
  0) dp_log.sh "[INFO]  [OK] [${validator}] $FILE_NAME" ;;
  *)
    dp_log.sh "[ERROR] [KO] [${validator}] $FILE_NAME"
    echo "==================================================================="
    echo -en "${validation_error}\n"
    n_errors=$((n_errors + 1))
    errors_files="${errors_files}\n  - ${FILE_NAME}"
    error_file=${FILE_NAME}
    echo "==================================================================="
    ;;
  esac
done < <(git status --porcelain | grep -e '^AM |^ M |^M |^A ' | awk '{print $2}')
[[ ${n_errors} == "0" ]] && exit 0
echo -en "

Files with hook errors: ${n_errors}
${errors_files}
You can disable hook in a file using:
DISABLE_HOOK=<file> git commit ...
Ex: To disable hooks for ${error_file}.
DISABLE_HOOK=${error_file} git commit ...
"

exit 1
